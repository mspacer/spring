1.
Inversion of Control - принцип программирования, при котором управлением выполнения программы (созданием объектов в частности) занимается фреймворк, а не программист
Происходит потеря контроля над управлением кодом: фреймворк управляет кодом программиста. Однако программист сосредотачивается над написанием бизнесслогики.

IoC Spring - Dependency Injection (DI)
DI внедряет зависимости через конструктор класса, параметры статического метода инициализации (фабричный метод), свойства объекта (set-методы)

IoC Container - объект, который занимается созданием других объектов (Bean типа Controller, Service, Repository) и внедрением в них зависимостей (DI).
Представляет собой ассоциативный массив (Map). 

IoC Container-у требуется метаинформация (Bean Definitions), которая описывае как создавать Beans, конфигурировать и внедрять в них зависимости.
Работает на основе Reflection API 
Существует три реализации метаинформации: XML-based, Annotation-based, Java-based

IoC Container pеализует интерфейсы org.springframework.beans.factory.BeanFactory и org.springframework.context.ApplicationContext
Для хмл-конфигурации - ClassPathXmlApplicationContext.
Содержит параметр beanFactory - метаинформация (Bean definition) о всех бирнах в конфигурации (пользовательскии и конфигурационные)
* beanDefinitionMap - мап бинов, где ключ - полное имя класс либо парамет id/name из конфигурации
        <bean id="..." name="" ...>
    Каждый параметр value содержит его метаинформацию
    constructorArgumentValues - метаинформация о аргументах конструктора (indexArgumentValues, если в конфигурации испольнован индех аргумента в конструкторе
    или genericArgumentValues, если по имени или типу параметра)

* beanDefinitionNames - список имен бинов
* singletonObjects - map эекземпляров классов бинов с ключем по имени. Собственно объект, возвращаемый по требованию
* beanPostProcessors

2.
Жизненный цикл бинов

Bean definition. Метаинформация о зависимотях и параметрах бинов. Собирается на основе конфигурционных файлов, аннотаций, java-конфигов.

Bean factory post processors
Бины, реализующие интерфейс BeanFactoryPostProcessor
Дополнительная обработка метаинформации. Как пример - внедрение информации из properties файлов.

Сортировка бинов из Bean definition.
Т.к. бины могут зависеть друг от друга, происходит их сортировка и инициализируются первыми независимые от других бины.

Вызов конструкторов бинов либо фабричного метода
    <bean name="..." class="..." factory-method="of">

Вызов set-методов
В хмл-конфигурации свойство
    <property name="properties"> <!-- setProperties(args)  -->

Bean post processors. Before initialization.
Бины, реализующие интерфейс BeanPostProcessor. Вызываются перед инициализацией бинов

Initialization callbacks
Инициализация бинов. Осуществляется тремя способами (в порядке приоритета)
1) аннотация @PostConstruct над методом
2) метод afterPropertiesSet. Класс должен реализовывать интерфейс InitializingBean
3) init-метод, прописанный в конфигурации
    <bean class="..."   init-method="init">

Bean post processors. After initialization.

Beans
Создание и возвращение бина вызывающему процессу.
В случае singleton-бина - бин кладется в контекст и существует в единственном экземпляре.

Destruction callbacks
Для singleton-бинов при закрытии контекста вызывается прописанный в конфигурации метод
    <bean class="...." scope="singleton"  destroy-method="destroyMethod">

3.
Bean factory post processors
 Являются обычными бинами, проходящими тот же жизненный цикл, только в первую очередь.
 Для этого Spring в списка бинов из конфигурации отбирает их и сортирует в порядке объявления, либо наличии
 реализуемых интерфейсов Ordered и PriorityOrdered (имеет высший приоритет) и возвращаемого значения из
 getOrder() (чем меньше число, тем больший приоритет).
 Определение принадлежности к классу beans post processors
       BeanFactoryPostProcessor.class.isAssignableFrom(bfpp.getClass())

4.
Bean post processors (annotationsConfig.png)
Позволяют управлять конфигурацией бинов посредством обработки аннотаци, что расширяет функционал
CommonAnnotationBeanPostProcessor - обрабатывает аннотации @PreDestroy, @PostConstruct (initialize callbacks), @Resource
ApplicationContextAwareProcessor - важный конфигурационный bpp, обрабатывающий бины, реализающие интерфейс Aware (осведомители)
Эти интерфейсы позволяют внедрить в бин различные конфигурационные объекты, включая контекст.
CommonAnnotationBeanPostProcessor реализует BeanFactoryAware, позволяющий получить BeanFactory
    public void setBeanFactory(BeanFactory beanFactory) {...}

С помощью bpp можно создавать обертки (proxy) бинов (AuditingBeanPostProcessors, TransactionBeanPostProcessors).

5. @Autowired, @Resource, @Value
Обрабатываются соответствующими bpp (annotationsConfig.png)
@Autowired - spring аннотация для внедрения зависимостей. Более функциональная чем @Resource
позволяет внедрять массивы, коллекции, мапы
Если в конфигурации есть несколько бинов одинакового типа, используется аннотация @Qualifier("...") с указанием id конкретного бина
Либо можно указать имя поля такое же как id.
Может устанавливатся над методами, но тогда имя параметра должно соответствовать id бина
Поскольку xml-конфигурация для создания бина требует конструктор, а если есть парамеры, то их нужно инициализировать -
@Autowired над конструктором нет смысла ставить.
@Autowired над конструктором ставится в конфигурации через аннотации и java
@Autowired над конструктором ставится если есть несколько конструкторов

@Resource - java аннотация в соответсвии с jsr250

@Value - позволяет внедрять заначения из property-файлов с использованием EL или SpEL

6. Classpath scanning
        <context:component-scan base-package="..."/>
base-package - перечень пакетов для сканировани. Бины для bean definitions должны быть помечены как
        @Component, @Repository, @Service, @Controller, @RestController
чисто логическое деление. Все являются @Component

в случае xml обработкой занимается ComponentScanBeanDefinitionParser, аннотаций - ComponentScanAnnotationParser, а
так же сооветствующие readers (componentScans.png, beanDefinitionReaders.png)

component-scan использует фильры для поиска бинов (componentScanFilters.png)
annotation - дефолтное поведение при use-default-filters="true". Ищутся все бины с аннотацией @Component (с потомками)

scope-resolver - класс определяющий scope бинов - singleton/prototype. По умолчанию в spring-context.xsd - ScopeMetadataResolver и его реализация AnnotationScopeMetadataResolver
AnnotationScopeMetadataResolver ищет аннотацию Scope.
помимо парамета value (singleton/prototype) имеет парамер proxyMode, позволяющий создавать прокси из бина

7. Java configuration
Обрабатывается ConfigurationClassPostProcessor-ром, который ищет классы, помеченные аннотацией @Configuration

Классы конфигурации по умолчанию создаются как прокси (proxyBeanMethods() default true;), поэтому бины, которые создаются
в методах через new на самом деле создаются только один раз.

@Bean
параметры initMethod(), destroyMethod() - аналоги @PostConstruct, @PreDestroy

@Profile("...")  - помеченная этой аннотацией сущность, будет создаваться в указанном профайле
Профайлов может быть несколько. К ним применимы операции ! & |
Активация профиля проводится чаще всего в файле Properties
    spring.profiles.active=web,prod
второй вариант через контекст
    context.getEnvironment().setActiveProfiles("web", "prod")

8. Listeners
Предствляет собой реализацию шаблона Слушатель событий
Обрабатываются bpp EventListenerMethodProcessor
Оперирует объектами Event (наследник ApplicationEvent или базового EventObject) - обычный POJO и Listener c произвольным методом acceptXXXX(Event),
помеченным аннотацией @EventListener
Неявно на основании каждой аннотации @EventListener будет создан объект типа ApplicationListener
Отслеживание событий (публикация евентов) осуществляется объектом-наследником интерфейса ApplicationEventPublisher
вызовом метода publishEvent. В результате из контекста будут вызываться все методы, помеченные аннотацией @EventListener и принимающие
соответствеющий параметр Event.
@EventListener имеет параметр condition, в котором на SpEL можно писать условие выполнения метода слушателя.

9. Spring boot
Spring -  альтернатива Java EE и EJB-бинам, фреймворк, реализующий по-своему Java EE стандарт.
Состоит из набора независимых модулей -
core — базовый функционал, реализующий понятия IoC (inversion of control) и DI (dependency injection);
AOP — Aspect-Oriented Programming — аспектно-ориентированое программирование, направленное на реализацию сквозной логики;
MVC и WebFlux — фреймворки для веб взаимодествия;
JDBC, ORM — технологии взаимодействия с базами данных;
Test — функционал для прозрачного, несложного тестирования данных Spring контейнера;
SpEL — Spring Expression Language — язык выражений Spring;
и т.д.
Каждый модуль - набор отдельных библиотек и своей конфигурации в приложении

Spring boot через Spring boot starters предоставляет возможность автоконфигурации каждого модуля и
решает проблему совместимости библиотек.
Версия Spring boot-а предоставляет pom, в котором указаны все зависимости библиотек, которые были протестированы
на совместимость в данной версии (Dependency management механизм)

@Conditional - позволяет динамически подключать конфигурацию, модуль, бин на основе написанного условия.
@Profile - пример реализации

Класс, запускающий приложение, должен быть помечен аннотацией @SpringBootApplication и быть единственным.
Эта аннотация помечается аннотациями
 - @SpringBootConfiguration, также единственная
 - @ComponentScan - автоматически сканирует все пакеты, которые входят в пакет с главным классом приложения

 application.properties - зарезервированное имя файла свойств, поэтому в конфигурации нет необходимости явно
 вызывать @PropertySource("classpath:application.properties")

spring.properties - еще один файл свойств, который читает специальным классом SpringProperties

Существует 14 вариантов передачи свойсв в приложение
https://docs.spring.io/spring-boot/reference/features/external-config.html
в зависимости от источника свойства могут переопределятся
application-{profile}.properties - свойства, связанные с профайлом

VM: -Ddb.username=wpsadmin2
command args: --db.username=wpsadmin2
Envirement: db.username=wpsadmin2

10. Yaml - yet another markup language
хорошо работает со сложными структурами (List, Map), позволяет создавать Java объекты
Обрабатывается YamlPropertiesFactoryBean
Не рекомендуется одновременное использование application.properties и application.yaml (*.yml)
Названия полей в Java объекте должны быть такими же как в файле.
Объект должен иметь конструктор без параметров и get/set методы, т.к. заполнение значениями происходит через Reflection
Маппинг файла на объект
- создание бина с аннотацией @ConfigurationProperties
- @ConfigurationProperties у бина + @ConfigurationPropertiesScan у класса приложения

11. Logging
По умоляанию - Logback
Дефолтные настройки логирования лежат в base.xml
В пропертях можно донастраивать или переопределять параметры - параметр logging

12. Testing
Для unit тестов необходим только MockitoExtension
Для интегрейшен тестов необходим контекст приложения для инициализации бинов и внедрения зависимостей
Для этого необходимо указать главный класс приложения (@SpringBootApplication), в котором происходит конфигурирования

Тесты не работают с yaml файлами. По умолчанюи только с *.properties
Поэтому, если какой-то @Component для инициализации требует проперти - в тестах не подымится ApplicationContext
Будет ошибка создания бина
    Error creating bean with name 'connectionPool' defined in file ....\ConnectionPool.class]:
    Unexpected exception during bean creation; nested exception is java.lang.IllegalArgumentException:
    Could not resolve placeholder 'db.username' in value "${db.username}"

для решения проблемы нужно использовать ConfigDataApplicationContextInitializer, который вызывает ConfigDataEnvironmentPostProcessor,
который в свою очередь обрабатывает все property в classpath

Все вышесказанное делает автоматически аннотация @SpringBootTest

@ActiveProfiles("test") - активирует тестовый профайл, соответственно будет считываться  application-test.yml,
свойства в котором будут перезаписывать application.yml

Вместо @Autowired для полей нужен конструктор. Для этого используется аннотация
    @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)

либо прописываем в spring.properties свойство (https://docs.spring.io/spring-framework/reference/appendix.html)
    spring.test.constructor.autowire.modе=all

13. Testing cash context
interface TestContext - контекст выполнения тестов, точка входа в которые TestContextManager

Если каждый тест использует разный набор аннотаций или переопределяет бины (например Mock), то каждый
тест имеет отличную от другого конфигурацию и, следовательно, будет создаваться свой контекст.
Поднятие контекста тяжеловесная операция и без необходимости стоит избегать

@TestConfiguration ищет @SpringBootApplication, поэтому ее можно использовать в
    @SpringBootTest(classes = TestApplicationRunner.class)

14. Database Postgres
postgres/password

Для работы с BD spring использует Hibernate (реализация JPA).
Автоконфигурация JPA осуществляется JpaBaseConfiguration и его наследник HibernateJpaConfiguration
JpaBaseConfiguration также конфигурирует транзакции
Свойства Hibernate: AvailableSettings. В спринге - HibernateProperties (в конфигурационных файлах spring.jpa.hibernate)

Hibernate не предоставляет слоя Repository, т.е. DAO реализовывается самостоятельно.
Нет встроенной обработки транзакция. Транзакция открывается и закрывается вручную.

Если бы Entity лежали в другом gradle-модуле, потребовалсь бы аннотация для ApplicationContextRunner
    @EntityScan("com.msp.spring.entity")

пример получения PersistenceContext, где можно посмотреть Entity в кеше
    final org.hibernate.engine.spi.SessionImplementor session = entityManager.unwrap( org.hibernate.engine.spi.SessionImplementor.class );
    final org.hibernate.engine.spi.PersistenceContext pc = session.getPersistenceContext();

15. Трансакции

В тестах обработчик транзакций TransactionalTestExecutionListener из starter-test.
По умольчанию после выполниеня транзакционного метода, происходит Rollback. Для сохранения изменений на методе(классе)
нужно поставить аннотацию @Commit

Для не-spring boot приложений, в которых отстутствует авто конфигурация, механизм транзакций включается аннотацией
  @EnableTransactionManagement

трансакции работают только над public методами

Классы, помеченные @Transactional, являются прокси-слассами, созданными cjlib

В случае Propagation.REQUIRES_NEW открывается новая сессия и соединение с БД

16. Repository

Дефолтная реализация DAO. JpaRepositoriesAutoConfiguration ищет интерфейсы-наследниеи Repository и генерирует прокси классы
(при этом нет необходимости помечать класс аннотацией @Repository)
Для не-spring boot приложений создание слоя repository включается аннотацией @EnableJpaRepositories
Не поддерживают операцию update

Наследники Repository (напр. CrudRepository, JpaRepository) уже реализуют набор базовых методов.
Базовая реализация - класс SimpleJpaRepository
Базовый класс запросов, которые строятся Repository - RepositoryQuery
Нааследники - PartTreeJpaQuery, NamedQuery
https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html

PartTreeJpaQuery в связке с PartTree парсит названия методов и строиз запрос к базе.

NamedQuery - запрос строится на HQL (Hibernate query language) в аннотации @NamedQuery либо в xml
    <named-query name="..."><query>...</query></named-query>
Имеет приоритет над  PartTreeJpaQuery, если название метода PartTreeJpaQuery и имени запроса в NamedQuery совпадают.
    @NamedQuery(name = "Company.findByName", query = "...")
соответствует методу findByName(String name) в CompanyRepository

NativeJpaQuery - использует аннотацию @Query над методом для выполнения как HQL так и нативных (nativeQuery = true) запросов.
Имеет приоритет над NamedQuery

Обновление из репозитория метод должен быть помечен аннотацией @Modifying. Иначе - QueryExecutionRequestException: Not supported for DML operations
Эта операция не обновляет PersistenceContext, поэтому его нужно принудительно чистить
Требуется установить  @Modifying(clearAutomatically = true)
Если перед этим в контексте были изменения, flush выполнится автоматически и flushAutomatically = true можно не ставить.
Соответственно, нельзя работать с сущностями, полученными до выполнения Modifying. Иначе можно получить LazyInitializationException для Lazy зависимостей.

17. Special parameters. Pageable
Чтобы сократить длину имени метода Repository выражение для Order можно заменить специальным параметром Sort.

Методы Repository помимо объектов и простых типов, могут возвращать Collections, Stream, Streamable, Slice, Page
Пэйдженация осуществляется классами
PageRequest - также относится к специальным параметрам запроса
Slice/Page - результат. Отличие - Page расширяет Slice и осуществляет дополнительный запрос на общее количество

18. EntityGraph
Если сущность имете зависимые объекты, помеченные как FetchType.LAZY, но требуется их получение, чтобы избежать дополнительного
запроса есть вариант написать HQl и указать
                join fetch u.company c
либо использовать EntityGraph и в аттрибуте attributePaths = {...) указать зависимые сущности.
Работаем как с запросами в @Query, так и с методами.

19. Projection (проекции)
Проекции на основные сущности, аналог DTO. В запросе будут участвовать только поля, объявленные в проекции, т.е.
можно получать только те поля, которые необходимы для данного фрагмента бизнес логики, а не всю сущность.
Могут быть классами и интерфейсами. Классы нельзя использовать с нативными запросами.

В обоих случаях поля/методы должны совпадать с именеми, возвращаемыми запросом

Projection с интерфейсами может использовать SpEL

20. Custom repositories
В случае сложных запросов, требующий criteria api/query dsl
Интерфейс + его реализация с префиксом Impl. Spring ищет именно с таким префиксом
Задается в конфигурации аннотацией EnableJpaRepositories (JpaRepositoriesAutoConfiguration -> JpaRepositoriesRegistrar).
Можно переопределить, задав эту аннотацию у конфигурационного файла.
Repository наследует этот интерфейс.

21. Auditing
Механизм отслеживания кто и когда изменил запись. В Hibernate и spring есть встроенная поддержка.
Для этого в аннотации @EntityListeners указвается класс аудита. В Spring встроенный.
    @EntityListeners(AuditingEntityListener.class)

Поля, подлежащие изменению, должны быть помеченны аннотациями @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy

Включение механизма аудита осуществляется аннотацией @EnableJpaAuditing над конфигурационным классом

Для @CreatedBy, @LastModifiedBy необходимо предоставить провайдера, который установит в эти поля нужные значения.
Для этого в EnableJpaAuditing есть параметр auditorAwareRef - имя бина, возвращающий AuditorAware<T> нужного типа.

22. Hibernate Envers
Аудирование операций
Создается специальная Entity (и соответствующая ей таблица), помеченная аннотацией @RevisionEntity (одна на все приложение).
Должна иметь два обязательных поля - id с аннотацией, и тип Timestamp c аннотацией @RevisionTimestamp
Могут быть другие поля.
Сущности, что требуется аудировать помечаются аннотацией @Audited
Свойство targetAuditMode = RelationTargetAuditMode.NOT_AUDITED указывает на аудировать зависимые сущности
Для коллекций нужно явно ставить аннотацию @NotAudit
Соответственно в базе должны быть таблица для этой сущности с аудируемыми полями. Имя таблицы сущности + _aud

Для запуска механизма, конфигурационный файл помечается аннотацией @EnableEnversRepositories
Эта аннотация переопределяет EnableJpaRepositories - т.е. пакет, от которого будут искаться @Repository,
поэтому нужно явно прописать класс runner, что бы относительно него осуществлялся поиск.

spring.jpa.properties.hibernate.hbm2ddl.auto: update - spring будет обновлять базу по существующим сущностиям

Чтобы иметь доступ к таблице аудита из Repository, соответствующий интерфейст расширяется интерфейсом RevisionRepository,
в котором первые два параметра соответсуют базовому Repository, а третий - тип id revision entity.

23. Querydsl
Плагин для грейдла  https://plugins.gradle.org/plugin/com.ewerk.gradle.plugins.querydsl

Наследование Repository интерфейса QuerydslPredicateExecutor, позволяет выполнять запросы по предикатам - аналог фильтров

24. JDBC Starter
Автоматически приходит как зависимост с spring data
Свойства - spring.jdbc (JdbcProperties)
JdbcTemplate - основной бин для запросов
NamedParameterJdbcTemplate расширяет JdbcTemplate и позволяет использовать именовынные параметры в запросах
Никак не связан с Hibernate, persistent context и сущностями. Хорошая практика из Resultset получать Dto или Projection

batch запросы - возможность выполнить несколько запросов (batchSize) за один сеанс tcp/ip связи с базой.
Обратно возвращается массив resultset-ов по числу запросов.
Выплоняется в одной трансакции, т.е. в случае не выполнения одного запроса, откатывается весь batch

Hibernate также отправляет batch запросы. По умолчанию bach_size = 50 (можно изменить в spring.jpa.properties.hibernate.bach_size )
batch запросы работают для insert, update, delete
Для select запросов существует параметр fetch_size, который задает коли-во записей, возвращаемых приложению. Если данных больше,
выполняется еще запрос (while(resultSet.next()) пока все данные не будут получены.

25. Spring MVC

Основан на шаблоне Front controller - единственный сервлет DispatcherServlet (конфигурация DispatcherServletAutoConfiguration)
Дефолтная конфигурация в WebMvcAutoConfiguration. Конфикорационные проперти - WebMvcProperties, WebProperties
Конфигурация встроенного web-сервера - ServletWebServerFactoryAutoConfiguration

Жизненный цикл DispatcherServlet:
- загрузка класса в web-сервер
- создание инстанса
- вызов метода init
- обработка входящих запросов в doGet/doPost/.../doXXX (реально в DispatcherServlet.doService)
- destroy при закрытии приложения

Задача DispatcherServlet.doService определить по урлу контроллер-обработчик запроса и вызвать его, передав ему входящие параметры
- mappedHandler = getHandler(processedRequest); - определение метода контроллера обработчика запроса (url path) и списка интерсепторов (вызываются перед и после метода)
- HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); - HandlerAdapter включает в себя WebApplicationContext и различные резолверы
   (RequestParamMethodArgumentResolver - обрабатывает @RequestParam, PathVariableMethodArgumentResolver - @PathVariable. см. DispatcherServlet.doDispatch() HandlerAdapter ha)
   Можно писать свои.
   Запускает метод контроллера и возвращает ModelAndView

Spring не имеет встроенной поддержики какого-нибудь варианта рендеринга View и по умолчанию возвращает результат "как есть"
Для подключения jsp нужна библиотека org.apache.tomcat.embed:tomcat-embed-jasper
В проперти
    spring.mvc.view:
          prefix: /WEB-INF/jsp - где лежат. важно указывать все "/"
          suffix: .jsp         - расширение файла.

Все контроллеры помечаются аннотацией @Controller
Все методы - @RequestMapping(value = "имя урла", method = RequestMethod.XXX), или сокращенный вариант - @GetMapping, @PostMapping и т.д.

Параметры запроса можно получить как параметр в методе, используя аннотация @RequestParam

Для установки сессионных атрибутов у контроллера объявляется аннотация @SessionAttributes с перечнем всех сессионных атрибутов.
При установке modelAndView.addObject(attributeName, attributeValue), attributeName сперва будет искаться в сессионных атрибутах,
а если не найден - будет устанавливаться как requestScope

Если специальный хендлер, обрабатывающиц ответ метода контроллера видит String в качестве возвращаемого результата, он интерпретирует
его как view.

Параметры формы или из get запроса мапятся на поля класса, помеченного @ModelAttribute
ModelAttribute может ставится и над методом, тогда этот метод будет вызываться перед каждым экщеном в контроллере.

Перенаправление запросов: forward, include, redirect
forward, include работают с сервлетами и jsp, redirect с url, поэтому более предпочтительный
Spring всегда делает forward или include (см InternalResourceView.renderMergedOutputModel())

Best practice for controllers
https://phauer.com/2015/restful-api-design-best-practices/