1.
Inversion of Control - принцип программирования, при котором управлением выполнения программы (созданием объектов в частности) занимается фреймворк, а не программист
Происходит потеря контроля над управлением кодом: фреймворк управляет кодом программиста. Однако программист сосредотачивается над написанием бизнесслогики.

IoC Spring - Dependency Injection (DI)
DI внедряет зависимости через конструктор класса, параметры статического метода инициализации (фабричный метод), свойства объекта (set-методы)

IoC Container - объект, который занимается созданием других объектов (Bean типа Controller, Service, Repository) и внедрением в них зависимостей (DI).
Представляет собой ассоциативный массив (Map). 

IoC Container-у требуется метаинформация (Bean Definitions), которая описывае как создавать Beans, конфигурировать и внедрять в них зависимости.
Работает на основе Reflection API 
Существует три реализации метаинформации: XML-based, Annotation-based, Java-based

IoC Container pеализует интерфейсы org.springframework.beans.factory.BeanFactory и org.springframework.context.ApplicationContext
Для хмл-конфигурации - ClassPathXmlApplicationContext.
Содержит параметр beanFactory - метаинформация (Bean definition) о всех бирнах в конфигурации (пользовательскии и конфигурационные)
* beanDefinitionMap - мап бинов, где ключ - полное имя класс либо парамет id/name из конфигурации
        <bean id="..." name="" ...>
    Каждый параметр value содержит его метаинформацию
    constructorArgumentValues - метаинформация о аргументах конструктора (indexArgumentValues, если в конфигурации испольнован индех аргумента в конструкторе
    или genericArgumentValues, если по имени или типу параметра)

* beanDefinitionNames - список имен бинов
* singletonObjects - map эекземпляров классов бинов с ключем по имени. Собственно объект, возвращаемый по требованию
* beanPostProcessors

2.
Жизненный цикл бинов

Bean definition. Метаинформация о зависимотях и параметрах бинов. Собирается на основе конфигурционных файлов, аннотаций, java-конфигов.

Bean factory post processors
Бины, реализующие интерфейс BeanFactoryPostProcessor
Дополнительная обработка метаинформации. Как пример - внедрение информации из properties файлов.

Сортировка бинов из Bean definition.
Т.к. бины могут зависеть друг от друга, происходит их сортировка и инициализируются первыми независимые от других бины.

Вызов конструкторов бинов либо фабричного метода
    <bean name="..." class="..." factory-method="of">

Вызов set-методов
В хмл-конфигурации свойство
    <property name="properties"> <!-- setProperties(args)  -->

Bean post processors. Before initialization.
Бины, реализующие интерфейс BeanPostProcessor. Вызываются перед инициализацией бинов

Initialization callbacks
Инициализация бинов. Осуществляется тремя способами (в порядке приоритета)
1) аннотация @PostConstruct над методом
2) метод afterPropertiesSet. Класс должен реализовывать интерфейс InitializingBean
3) init-метод, прописанный в конфигурации
    <bean class="..."   init-method="init">

Bean post processors. After initialization.

Beans
Создание и возвращение бина вызывающему процессу.
В случае singleton-бина - бин кладется в контекст и существует в единственном экземпляре.

Destruction callbacks
Для singleton-бинов при закрытии контекста вызывается прописанный в конфигурации метод
    <bean class="...." scope="singleton"  destroy-method="destroyMethod">

3.
Bean factory post processors
 Являются обычными бинами, проходящими тот же жизненный цикл, только в первую очередь.
 Для этого Spring в списка бинов из конфигурации отбирает их и сортирует в порядке объявления, либо наличии
 реализуемых интерфейсов Ordered и PriorityOrdered (имеет высший приоритет) и возвращаемого значения из
 getOrder() (чем меньше число, тем больший приоритет).
 Определение принадлежности к классу beans post processors
       BeanFactoryPostProcessor.class.isAssignableFrom(bfpp.getClass())

4.
Bean post processors (annotationsConfig.png)
Позволяют управлять конфигурацией бинов посредством обработки аннотаци, что расширяет функционал
CommonAnnotationBeanPostProcessor - обрабатывает аннотации @PreDestroy, @PostConstruct (initialize callbacks), @Resource
ApplicationContextAwareProcessor - важный конфигурационный bpp, обрабатывающий бины, реализающие интерфейс Aware (осведомители)
Эти интерфейсы позволяют внедрить в бин различные конфигурационные объекты, включая контекст.
CommonAnnotationBeanPostProcessor реализует BeanFactoryAware, позволяющий получить BeanFactory
    public void setBeanFactory(BeanFactory beanFactory) {...}

С помощью bpp можно создавать обертки (proxy) бинов (AuditingBeanPostProcessors, TransactionBeanPostProcessors).

5. @Autowired, @Resource, @Value
Обрабатываются соответствующими bpp (annotationsConfig.png)
@Autowired - spring аннотация для внедрения зависимостей. Более функциональная чем @Resource
позволяет внедрять массивы, коллекции, мапы
Если в конфигурации есть несколько бинов одинакового типа, используется аннотация @Qualifier("...") с указанием id конкретного бина
Либо можно указать имя поля такое же как id.
Может устанавливатся над методами, но тогда имя параметра должно соответствовать id бина
Поскольку xml-конфигурация для создания бина требует конструктор, а если есть парамеры, то их нужно инициализировать -
@Autowired над конструктором нет смысла ставить.
@Autowired над конструктором ставится в конфигурации через аннотации и java
@Autowired над конструктором ставится если есть несколько конструкторов

@Resource - java аннотация в соответсвии с jsr250

@Value - позволяет внедрять заначения из property-файлов с использованием EL или SpEL

6. Classpath scanning
        <context:component-scan base-package="..."/>
base-package - перечень пакетов для сканировани. Бины для bean definitions должны быть помечены как
        @Component, @Repository, @Service, @Controller, @RestController
чисто логическое деление. Все являются @Component

в случае xml обработкой занимается ComponentScanBeanDefinitionParser, аннотаций - ComponentScanAnnotationParser, а
так же сооветствующие readers (componentScans.png, beanDefinitionReaders.png)

component-scan использует фильры для поиска бинов (componentScanFilters.png)
annotation - дефолтное поведение при use-default-filters="true". Ищутся все бины с аннотацией @Component (с потомками)

scope-resolver - класс определяющий scope бинов - singleton/prototype. По умолчанию в spring-context.xsd - ScopeMetadataResolver и его реализация AnnotationScopeMetadataResolver
AnnotationScopeMetadataResolver ищет аннотацию Scope.
помимо парамета value (singleton/prototype) имеет парамер proxyMode, позволяющий создавать прокси из бина

7. Java configuration
Обрабатывается ConfigurationClassPostProcessor-ром, который ищет классы, помеченные аннотацией @Configuration

Классы конфигурации по умолчанию создаются как прокси (proxyBeanMethods() default true;), поэтому бины, которые создаются
в методах через new на самом деле создаются только один раз.

@Bean
параметры initMethod(), destroyMethod() - аналоги @PostConstruct, @PreDestroy

@Profile("...")  - помеченная этой аннотацией сущность, будет создаваться в указанном профайле
Профайлов может быть несколько. К ним применимы операции ! & |
Активация профиля проводится чаще всего в файле Properties
    spring.profiles.active=web,prod
второй вариант через контекст
    context.getEnvironment().setActiveProfiles("web", "prod")

8. Listeners
Предствляет собой реализацию шаблона Слушатель событий
Обрабатываются bpp EventListenerMethodProcessor
Оперирует объектами Event (наследник ApplicationEvent или базового EventObject) - обычный POJO и Listener c произвольным методом acceptXXXX(Event),
помеченным аннотацией @EventListener
Неявно на основании каждой аннотации @EventListener будет создан объект типа ApplicationListener
Отслеживание событий (публикация евентов) осуществляется объектом-наследником интерфейса ApplicationEventPublisher
вызовом метода publishEvent. В результате из контекста будут вызываться все методы, помеченные аннотацией @EventListener и принимающие
соответствеющий параметр Event.
@EventListener имеет параметр condition, в котором на SpEL можно писать условие выполнения метода слушателя.

9. Spring boot
Spring -  альтернатива Java EE и EJB-бинам, фреймворк, реализующий по-своему Java EE стандарт.
Состоит из набора независимых модулей -
core — базовый функционал, реализующий понятия IoC (inversion of control) и DI (dependency injection);
AOP — Aspect-Oriented Programming — аспектно-ориентированое программирование, направленное на реализацию сквозной логики;
MVC и WebFlux — фреймворки для веб взаимодествия;
JDBC, ORM — технологии взаимодействия с базами данных;
Test — функционал для прозрачного, несложного тестирования данных Spring контейнера;
SpEL — Spring Expression Language — язык выражений Spring;
и т.д.
Каждый модуль - набор отдельных библиотек и своей конфигурации в приложении

Spring boot через Spring boot starters предоставляет возможность автоконфигурации каждого модуля и
решает проблему совместимости библиотек.
Версия Spring boot-а предоставляет pom, в котором указаны все зависимости библиотек, которые были протестированы
на совместимость в данной версии (Dependency management механизм)

@Conditional - позволяет динамически подключать конфигурацию, модуль, бин на основе написанного условия.
@Profile - пример реализации

Класс, запускающий приложение, должен быть помечен аннотацией @SpringBootApplication и быть единственным.
Эта аннотация помечается аннотациями
 - @SpringBootConfiguration, также единственная
 - @ComponentScan - автоматически сканирует все пакеты, которые входят в пакет с главным классом приложения

 application.properties - зарезервированное имя файла свойств, поэтому в конфигурации нет необходимости явно
 вызывать @PropertySource("classpath:application.properties")

spring.properties - еще один файл свойств, который читает специальным классом SpringProperties

Существует 14 вариантов передачи свойсв в приложение
https://docs.spring.io/spring-boot/reference/features/external-config.html
в зависимости от источника свойства могут переопределятся
application-{profile}.properties - свойства, связанные с профайлом

VM: -Ddb.username=wpsadmin2
command args: --db.username=wpsadmin2
Envirement: db.username=wpsadmin2

10. Yaml - yet another markup language
хорошо работает со сложными структурами (List, Map), позволяет создавать Java объекты
Обрабатывается YamlPropertiesFactoryBean
Не рекомендуется одновременное использование application.properties и application.yaml (*.yml)
Названия полей в Java объекте должны быть такими же как в файле.
Объект должен иметь конструктор без параметров и get/set методы, т.к. заполнение значениями происходит через Reflection
Маппинг файла на объект
- создание бина с аннотацией @ConfigurationProperties
- @ConfigurationProperties у бина + @ConfigurationPropertiesScan у класса приложения

11. Logging
По умоляанию - Logback
Дефолтные настройки логирования лежат в base.xml
В пропертях можно донастраивать или переопределять параметры - параметр logging

12. Testing
Для unit тестов необходим только MockitoExtension
Для интегрейшен тестов необходим контекст приложения для инициализации бинов и внедрения зависимостей
Для этого необходимо указать главный класс приложения (@SpringBootApplication), в котором происходит конфигурирования

Тесты не работают с yaml файлами. По умолчанюи только с *.properties
Поэтому, если какой-то @Component для инициализации требует проперти - в тестах не подымится ApplicationContext
Будет ошибка создания бина
    Error creating bean with name 'connectionPool' defined in file ....\ConnectionPool.class]:
    Unexpected exception during bean creation; nested exception is java.lang.IllegalArgumentException:
    Could not resolve placeholder 'db.username' in value "${db.username}"

для решения проблемы нужно использовать ConfigDataApplicationContextInitializer, который вызывает ConfigDataEnvironmentPostProcessor,
который в свою очередь обрабатывает все property в classpath

Все вышесказанное делает автоматически аннотация @SpringBootTest

@ActiveProfiles("test") - активирует тестовый профайл, соответственно будет считываться  application-test.yml,
свойства в котором будут перезаписывать application.yml

Вместо @Autowired для полей нужен конструктор. Для этого используется аннотация
    @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)

либо прописываем в spring.properties свойство (https://docs.spring.io/spring-framework/reference/appendix.html)
    spring.test.constructor.autowire.modе=all

13. Testing cash context
interface TestContext - контекст выполнения тестов, точка входа в которые TestContextManager

Если каждый тест использует разный набор аннотаций или переопределяет бины (например Mock), то каждый
тест имеет отличную от другого конфигурацию и, следовательно, будет создаваться свой контекст.
Поднятие контекста тяжеловесная операция и без необходимости стоит избегать

@TestConfiguration ищет @SpringBootApplication, поэтому ее можно использовать в
    @SpringBootTest(classes = TestApplicationRunner.class)

14. Database Postgres
postgres/password

Для работы с BD spring использует Hibernate (реализация JPA).
Автоконфигурация JPA осуществляется JpaBaseConfiguration и его наследник HibernateJpaConfiguration
JpaBaseConfiguration также конфигурирует транзакции
Свойства Hibernate: AvailableSettings. В спринге - HibernateProperties (в конфигурационных файлах spring.jpa.hibernate)

Hibernate не предоставляет слоя Repository, т.е. DAO реализовывается самостоятельно.
Нет встроенной обработки транзакция. Транзакция открывается и закрывается вручную.

Если бы Entity лежали в другом gradle-модуле, потребовалсь бы аннотация для ApplicationContextRunner
    @EntityScan("com.msp.spring.entity")

пример получения PersistenceContext, где можно посмотреть Entity в кеше
    final org.hibernate.engine.spi.SessionImplementor session = entityManager.unwrap( org.hibernate.engine.spi.SessionImplementor.class );
    final org.hibernate.engine.spi.PersistenceContext pc = session.getPersistenceContext();

15. Трансакции

В тестах обработчик транзакций TransactionalTestExecutionListener из starter-test.
По умольчанию после выполниеня транзакционного метода, происходит Rollback. Для сохранения изменений на методе(классе)
нужно поставить аннотацию @Commit

Для не-spring boot приложений, в которых отстутствует авто конфигурация, механизм транзакций включается аннотацией
  @EnableTransactionManagement

трансакции работают только над public методами

Классы, помеченные @Transactional, являются прокси-слассами, созданными cjlib

В случае Propagation.REQUIRES_NEW открывается новая сессия и соединение с БД

16. Repository

Дефолтная реализация DAO. JpaRepositoriesAutoConfiguration ищет интерфейсы-наследниеи Repository и генерирует прокси классы
(при этом нет необходимости помечать класс аннотацией @Repository)
Для не-spring boot приложений создание слоя repository включается аннотацией @EnableJpaRepositories
Не поддерживают операцию update

Наследники Repository (напр. CrudRepository, JpaRepository) уже реализуют набор базовых методов.
Базовая реализация - класс SimpleJpaRepository
Базовый класс запросов, которые строятся Repository - RepositoryQuery
Нааследники - PartTreeJpaQuery, NamedQuery
https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html

PartTreeJpaQuery в связке с PartTree парсит названия методов и строиз запрос к базе.

NamedQuery - запрос строится на HQL (Hibernate query language) в аннотации @NamedQuery либо в xml
    <named-query name="..."><query>...</query></named-query>
Имеет приоритет над  PartTreeJpaQuery, если название метода PartTreeJpaQuery и имени запроса в NamedQuery совпадают.
    @NamedQuery(name = "Company.findByName", query = "...")
соответствует методу findByName(String name) в CompanyRepository

NativeJpaQuery - использует аннотацию @Query над методом для выполнения как HQL так и нативных (nativeQuery = true) запросов.
Имеет приоритет над NamedQuery

Обновление из репозитория метод должен быть помечен аннотацией @Modifying. Иначе - QueryExecutionRequestException: Not supported for DML operations
Эта операция не обновляет PersistenceContext, поэтому его нужно принудительно чистить
Требуется установить  @Modifying(clearAutomatically = true)
Если перед этим в контексте были изменения, flush выполнится автоматически и flushAutomatically = true можно не ставить.
Соответственно, нельзя работать с сущностями, полученными до выполнения Modifying. Иначе можно получить LazyInitializationException для Lazy зависимостей.