Spring Boot Gradle Plugin
https://docs.spring.io/spring-boot/docs/2.0.x/gradle-plugin/reference/html/
https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/html/index.html
https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/index.html

1.
Inversion of Control - принцип программирования, при котором управлением выполнения программы (созданием объектов в частности) занимается фреймворк, а не программист
Происходит потеря контроля над управлением кодом: фреймворк управляет кодом программиста. Однако программист сосредотачивается над написанием бизнесслогики.

IoC Spring - Dependency Injection (DI)
DI внедряет зависимости через конструктор класса, параметры статического метода инициализации (фабричный метод), свойства объекта (set-методы)

IoC Container - объект, который занимается созданием других объектов (Bean типа Controller, Service, Repository) и внедрением в них зависимостей (DI).
Представляет собой ассоциативный массив (Map). 

IoC Container-у требуется метаинформация (Bean Definitions), которая описывае как создавать Beans, конфигурировать и внедрять в них зависимости.
Работает на основе Reflection API 
Существует три реализации метаинформации: XML-based, Annotation-based, Java-based

IoC Container pеализует интерфейсы org.springframework.beans.factory.BeanFactory и org.springframework.context.ApplicationContext
Для хмл-конфигурации - ClassPathXmlApplicationContext.
Содержит параметр beanFactory - метаинформация (Bean definition) о всех бирнах в конфигурации (пользовательскии и конфигурационные)
* beanDefinitionMap - мап бинов, где ключ - полное имя класс либо парамет id/name из конфигурации
        <bean id="..." name="" ...>
    Каждый параметр value содержит его метаинформацию
    constructorArgumentValues - метаинформация о аргументах конструктора (indexArgumentValues, если в конфигурации испольнован индех аргумента в конструкторе
    или genericArgumentValues, если по имени или типу параметра)

* beanDefinitionNames - список имен бинов
* singletonObjects - map эекземпляров классов бинов с ключем по имени. Собственно объект, возвращаемый по требованию
* beanPostProcessors

2.
Жизненный цикл бинов

Bean definition. Метаинформация о зависимотях и параметрах бинов. Собирается на основе конфигурционных файлов, аннотаций, java-конфигов.

Bean factory post processors
Бины, реализующие интерфейс BeanFactoryPostProcessor
Дополнительная обработка метаинформации. Как пример - внедрение информации из properties файлов.

Сортировка бинов из Bean definition.
Т.к. бины могут зависеть друг от друга, происходит их сортировка и инициализируются первыми независимые от других бины.

Вызов конструкторов бинов либо фабричного метода
    <bean name="..." class="..." factory-method="of">

Вызов set-методов
В хмл-конфигурации свойство
    <property name="properties"> <!-- setProperties(args)  -->

Bean post processors. Before initialization.
Бины, реализующие интерфейс BeanPostProcessor. Вызываются перед инициализацией бинов

Initialization callbacks
Инициализация бинов. Осуществляется тремя способами (в порядке приоритета)
1) аннотация @PostConstruct над методом
2) метод afterPropertiesSet. Класс должен реализовывать интерфейс InitializingBean
3) init-метод, прописанный в конфигурации
    <bean class="..."   init-method="init">

Bean post processors. After initialization.

Beans
Создание и возвращение бина вызывающему процессу.
В случае singleton-бина - бин кладется в контекст и существует в единственном экземпляре.

Destruction callbacks
Для singleton-бинов при закрытии контекста вызывается прописанный в конфигурации метод
    <bean class="...." scope="singleton"  destroy-method="destroyMethod">

3.
Bean factory post processors
 Являются обычными бинами, проходящими тот же жизненный цикл, только в первую очередь.
 Для этого Spring в списка бинов из конфигурации отбирает их и сортирует в порядке объявления, либо наличии
 реализуемых интерфейсов Ordered и PriorityOrdered (имеет высший приоритет) и возвращаемого значения из
 getOrder() (чем меньше число, тем больший приоритет).
 Определение принадлежности к классу beans post processors
       BeanFactoryPostProcessor.class.isAssignableFrom(bfpp.getClass())

4.
Bean post processors (annotationsConfig.png)
Позволяют управлять конфигурацией бинов посредством обработки аннотаци, что расширяет функционал
CommonAnnotationBeanPostProcessor - обрабатывает аннотации @PreDestroy, @PostConstruct (initialize callbacks), @Resource
ApplicationContextAwareProcessor - важный конфигурационный bpp, обрабатывающий бины, реализающие интерфейс Aware (осведомители)
Эти интерфейсы позволяют внедрить в бин различные конфигурационные объекты, включая контекст.
CommonAnnotationBeanPostProcessor реализует BeanFactoryAware, позволяющий получить BeanFactory
    public void setBeanFactory(BeanFactory beanFactory) {...}

С помощью bpp можно создавать обертки (proxy) бинов (AuditingBeanPostProcessors, TransactionBeanPostProcessors).

5. @Autowired, @Resource, @Value
Обрабатываются соответствующими bpp (annotationsConfig.png)
@Autowired - spring аннотация для внедрения зависимостей. Более функциональная чем @Resource
позволяет внедрять массивы, коллекции, мапы
Если в конфигурации есть несколько бинов одинакового типа, используется аннотация @Qualifier("...") с указанием id конкретного бина
Либо можно указать имя поля такое же как id.
Может устанавливатся над методами, но тогда имя параметра должно соответствовать id бина
Поскольку xml-конфигурация для создания бина требует конструктор, а если есть парамеры, то их нужно инициализировать -
@Autowired над конструктором нет смысла ставить.
@Autowired над конструктором ставится в конфигурации через аннотации и java
@Autowired над конструктором ставится если есть несколько конструкторов

@Resource - java аннотация в соответсвии с jsr250

@Value - позволяет внедрять заначения из property-файлов с использованием EL или SpEL

6. Classpath scanning
        <context:component-scan base-package="..."/>
base-package - перечень пакетов для сканировани. Бины для bean definitions должны быть помечены как
        @Component, @Repository, @Service, @Controller, @RestController
чисто логическое деление. Все являются @Component

в случае xml обработкой занимается ComponentScanBeanDefinitionParser, аннотаций - ComponentScanAnnotationParser, а
так же сооветствующие readers (componentScans.png, beanDefinitionReaders.png)

component-scan использует фильры для поиска бинов (componentScanFilters.png)
annotation - дефолтное поведение при use-default-filters="true". Ищутся все бины с аннотацией @Component (с потомками)

scope-resolver - класс определяющий scope бинов - singleton/prototype. По умолчанию в spring-context.xsd - ScopeMetadataResolver и его реализация AnnotationScopeMetadataResolver
AnnotationScopeMetadataResolver ищет аннотацию Scope.
помимо парамета value (singleton/prototype) имеет парамер proxyMode, позволяющий создавать прокси из бина

7. Java configuration
Обрабатывается ConfigurationClassPostProcessor-ром, который ищет классы, помеченные аннотацией @Configuration

Классы конфигурации по умолчанию создаются как прокси (proxyBeanMethods() default true;), поэтому бины, которые создаются
в методах через new на самом деле создаются только один раз.

@Bean
параметры initMethod(), destroyMethod() - аналоги @PostConstruct, @PreDestroy

@Profile("...")  - помеченная этой аннотацией сущность, будет создаваться в указанном профайле
Профайлов может быть несколько. К ним применимы операции ! & |
Активация профиля проводится чаще всего в файле Properties
    spring.profiles.active=web,prod
второй вариант через контекст
    context.getEnvironment().setActiveProfiles("web", "prod")

8. Listeners
Предствляет собой реализацию шаблона Слушатель событий
Обрабатываются bpp EventListenerMethodProcessor
Оперирует объектами Event (наследник ApplicationEvent или базового EventObject) - обычный POJO и Listener c произвольным методом acceptXXXX(Event),
помеченным аннотацией @EventListener
Неявно на основании каждой аннотации @EventListener будет создан объект типа ApplicationListener
Отслеживание событий (публикация евентов) осуществляется объектом-наследником интерфейса ApplicationEventPublisher
вызовом метода publishEvent. В результате из контекста будут вызываться все методы, помеченные аннотацией @EventListener и принимающие
соответствеющий параметр Event.
@EventListener имеет параметр condition, в котором на SpEL можно писать условие выполнения метода слушателя.

9. Spring boot
Spring -  альтернатива Java EE и EJB-бинам, фреймворк, реализующий по-своему Java EE стандарт.
Состоит из набора независимых модулей -
core — базовый функционал, реализующий понятия IoC (inversion of control) и DI (dependency injection);
AOP — Aspect-Oriented Programming — аспектно-ориентированое программирование, направленное на реализацию сквозной логики;
MVC и WebFlux — фреймворки для веб взаимодествия;
JDBC, ORM — технологии взаимодействия с базами данных;
Test — функционал для прозрачного, несложного тестирования данных Spring контейнера;
SpEL — Spring Expression Language — язык выражений Spring;
и т.д.
Каждый модуль - набор отдельных библиотек и своей конфигурации в приложении

Spring boot через Spring boot starters предоставляет возможность автоконфигурации каждого модуля и
решает проблему совместимости библиотек.
Версия Spring boot-а предоставляет pom, в котором указаны все зависимости библиотек, которые были протестированы
на совместимость в данной версии (Dependency management механизм)

@Conditional - позволяет динамически подключать конфигурацию, модуль, бин на основе написанного условия.
@Profile - пример реализации

Класс, запускающий приложение, должен быть помечен аннотацией @SpringBootApplication и быть единственным.
Эта аннотация помечается аннотациями
 - @SpringBootConfiguration, также единственная
 - @ComponentScan - автоматически сканирует все пакеты, которые входят в пакет с главным классом приложения

 application.properties - зарезервированное имя файла свойств, поэтому в конфигурации нет необходимости явно
 вызывать @PropertySource("classpath:application.properties")

spring.properties - еще один файл свойств, который читает специальным классом SpringProperties

Существует 14 вариантов передачи свойсв в приложение
https://docs.spring.io/spring-boot/reference/features/external-config.html
в зависимости от источника свойства могут переопределятся
application-{profile}.properties - свойства, связанные с профайлом

VM: -Ddb.username=wpsadmin2
command args: --db.username=wpsadmin2
Envirement: db.username=wpsadmin2

10. Yaml - yet another markup language
хорошо работает со сложными структурами (List, Map), позволяет создавать Java объекты
Обрабатывается YamlPropertiesFactoryBean
Не рекомендуется одновременное использование application.properties и application.yaml (*.yml)
Названия полей в Java объекте должны быть такими же как в файле.
Объект должен иметь конструктор без параметров и get/set методы, т.к. заполнение значениями происходит через Reflection
Маппинг файла на объект
- создание бина с аннотацией @ConfigurationProperties
- @ConfigurationProperties у бина + @ConfigurationPropertiesScan у класса приложения

11. Logging
По умоляанию - Logback
Дефолтные настройки логирования лежат в base.xml
В пропертях можно донастраивать или переопределять параметры - параметр logging

12. Testing
Для unit тестов необходим только MockitoExtension
Для интегрейшен тестов необходим контекст приложения для инициализации бинов и внедрения зависимостей
Для этого необходимо указать главный класс приложения (@SpringBootApplication), в котором происходит конфигурирования

Тесты не работают с yaml файлами. По умолчанюи только с *.properties
Поэтому, если какой-то @Component для инициализации требует проперти - в тестах не подымится ApplicationContext
Будет ошибка создания бина
    Error creating bean with name 'connectionPool' defined in file ....\ConnectionPool.class]:
    Unexpected exception during bean creation; nested exception is java.lang.IllegalArgumentException:
    Could not resolve placeholder 'db.username' in value "${db.username}"

для решения проблемы нужно использовать ConfigDataApplicationContextInitializer, который вызывает ConfigDataEnvironmentPostProcessor,
который в свою очередь обрабатывает все property в classpath

Все вышесказанное делает автоматически аннотация @SpringBootTest

@ActiveProfiles("test") - активирует тестовый профайл, соответственно будет считываться  application-test.yml,
свойства в котором будут перезаписывать application.yml

Вместо @Autowired для полей нужен конструктор. Для этого используется аннотация
    @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)

либо прописываем в spring.properties свойство (https://docs.spring.io/spring-framework/reference/appendix.html)
    spring.test.constructor.autowire.modе=all

13. Testing cash context
interface TestContext - контекст выполнения тестов, точка входа в которые TestContextManager

Если каждый тест использует разный набор аннотаций или переопределяет бины (например Mock), то каждый
тест имеет отличную от другого конфигурацию и, следовательно, будет создаваться свой контекст.
Поднятие контекста тяжеловесная операция и без необходимости стоит избегать

@TestConfiguration ищет @SpringBootApplication, поэтому ее можно использовать в
    @SpringBootTest(classes = TestApplicationRunner.class)

14. Database Postgres
postgres/password

Для работы с BD spring использует Hibernate (реализация JPA).
Автоконфигурация JPA осуществляется JpaBaseConfiguration и его наследник HibernateJpaConfiguration
JpaBaseConfiguration также конфигурирует транзакции
Свойства Hibernate: AvailableSettings. В спринге - HibernateProperties (в конфигурационных файлах spring.jpa.hibernate)

Hibernate не предоставляет слоя Repository, т.е. DAO реализовывается самостоятельно.
Нет встроенной обработки транзакция. Транзакция открывается и закрывается вручную.

Если бы Entity лежали в другом gradle-модуле, потребовалсь бы аннотация для ApplicationContextRunner
    @EntityScan("com.msp.spring.entity")

пример получения PersistenceContext, где можно посмотреть Entity в кеше
    final org.hibernate.engine.spi.SessionImplementor session = entityManager.unwrap( org.hibernate.engine.spi.SessionImplementor.class );
    final org.hibernate.engine.spi.PersistenceContext pc = session.getPersistenceContext();

15. Трансакции

В тестах обработчик транзакций TransactionalTestExecutionListener из starter-test.
По умольчанию после выполниеня транзакционного метода, происходит Rollback. Для сохранения изменений на методе(классе)
нужно поставить аннотацию @Commit

Для не-spring boot приложений, в которых отстутствует авто конфигурация, механизм транзакций включается аннотацией
  @EnableTransactionManagement

трансакции работают только над public методами

Классы, помеченные @Transactional, являются прокси-слассами, созданными cjlib

В случае Propagation.REQUIRES_NEW открывается новая сессия и соединение с БД

16. Repository

Дефолтная реализация DAO. JpaRepositoriesAutoConfiguration ищет интерфейсы-наследниеи Repository и генерирует прокси классы
(при этом нет необходимости помечать класс аннотацией @Repository)
Для не-spring boot приложений создание слоя repository включается аннотацией @EnableJpaRepositories
Не поддерживают операцию update

Наследники Repository (напр. CrudRepository, JpaRepository) уже реализуют набор базовых методов.
Базовая реализация - класс SimpleJpaRepository
Базовый класс запросов, которые строятся Repository - RepositoryQuery
Нааследники - PartTreeJpaQuery, NamedQuery
https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html

PartTreeJpaQuery в связке с PartTree парсит названия методов и строиз запрос к базе.

NamedQuery - запрос строится на HQL (Hibernate query language) в аннотации @NamedQuery либо в xml
    <named-query name="..."><query>...</query></named-query>
Имеет приоритет над  PartTreeJpaQuery, если название метода PartTreeJpaQuery и имени запроса в NamedQuery совпадают.
    @NamedQuery(name = "Company.findByName", query = "...")
соответствует методу findByName(String name) в CompanyRepository

NativeJpaQuery - использует аннотацию @Query над методом для выполнения как HQL так и нативных (nativeQuery = true) запросов.
Имеет приоритет над NamedQuery

Обновление из репозитория метод должен быть помечен аннотацией @Modifying. Иначе - QueryExecutionRequestException: Not supported for DML operations
Эта операция не обновляет PersistenceContext, поэтому его нужно принудительно чистить
Требуется установить  @Modifying(clearAutomatically = true)
Если перед этим в контексте были изменения, flush выполнится автоматически и flushAutomatically = true можно не ставить.
Соответственно, нельзя работать с сущностями, полученными до выполнения Modifying. Иначе можно получить LazyInitializationException для Lazy зависимостей.

17. Special parameters. Pageable
Чтобы сократить длину имени метода Repository выражение для Order можно заменить специальным параметром Sort.

Методы Repository помимо объектов и простых типов, могут возвращать Collections, Stream, Streamable, Slice, Page
Пэйдженация осуществляется классами
PageRequest - также относится к специальным параметрам запроса
Slice/Page - результат. Отличие - Page расширяет Slice и осуществляет дополнительный запрос на общее количество

18. EntityGraph
Если сущность имете зависимые объекты, помеченные как FetchType.LAZY, но требуется их получение, чтобы избежать дополнительного
запроса есть вариант написать HQl и указать
                join fetch u.company c
либо использовать EntityGraph и в аттрибуте attributePaths = {...) указать зависимые сущности.
Работаем как с запросами в @Query, так и с методами.

19. Projection (проекции)
Проекции на основные сущности, аналог DTO. В запросе будут участвовать только поля, объявленные в проекции, т.е.
можно получать только те поля, которые необходимы для данного фрагмента бизнес логики, а не всю сущность.
Могут быть классами и интерфейсами. Классы нельзя использовать с нативными запросами.

В обоих случаях поля/методы должны совпадать с именеми, возвращаемыми запросом

Projection с интерфейсами может использовать SpEL

20. Custom repositories
В случае сложных запросов, требующий criteria api/query dsl
Интерфейс + его реализация с префиксом Impl. Spring ищет именно с таким префиксом
Задается в конфигурации аннотацией EnableJpaRepositories (JpaRepositoriesAutoConfiguration -> JpaRepositoriesRegistrar).
Можно переопределить, задав эту аннотацию у конфигурационного файла.
Repository наследует этот интерфейс.

21. Auditing
Механизм отслеживания кто и когда изменил запись. В Hibernate и spring есть встроенная поддержка.
Для этого в аннотации @EntityListeners указвается класс аудита. В Spring встроенный.
    @EntityListeners(AuditingEntityListener.class)

Поля, подлежащие изменению, должны быть помеченны аннотациями @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy

Включение механизма аудита осуществляется аннотацией @EnableJpaAuditing над конфигурационным классом

Для @CreatedBy, @LastModifiedBy необходимо предоставить провайдера, который установит в эти поля нужные значения.
Для этого в EnableJpaAuditing есть параметр auditorAwareRef - имя бина, возвращающий AuditorAware<T> нужного типа.

22. Hibernate Envers
Аудирование операций
Создается специальная Entity (и соответствующая ей таблица), помеченная аннотацией @RevisionEntity (одна на все приложение).
Должна иметь два обязательных поля - id с аннотацией, и тип Timestamp c аннотацией @RevisionTimestamp
Могут быть другие поля.
Сущности, что требуется аудировать помечаются аннотацией @Audited
Свойство targetAuditMode = RelationTargetAuditMode.NOT_AUDITED указывает на аудировать зависимые сущности
Для коллекций нужно явно ставить аннотацию @NotAudit
Соответственно в базе должны быть таблица для этой сущности с аудируемыми полями. Имя таблицы сущности + _aud

Для запуска механизма, конфигурационный файл помечается аннотацией @EnableEnversRepositories
Эта аннотация переопределяет EnableJpaRepositories - т.е. пакет, от которого будут искаться @Repository,
поэтому нужно явно прописать класс runner, что бы относительно него осуществлялся поиск.

spring.jpa.properties.hibernate.hbm2ddl.auto: update - spring будет обновлять базу по существующим сущностиям

Чтобы иметь доступ к таблице аудита из Repository, соответствующий интерфейст расширяется интерфейсом RevisionRepository,
в котором первые два параметра соответсуют базовому Repository, а третий - тип id revision entity.

23. Querydsl
Плагин для грейдла  https://plugins.gradle.org/plugin/com.ewerk.gradle.plugins.querydsl

Наследование Repository интерфейса QuerydslPredicateExecutor, позволяет выполнять запросы по предикатам - аналог фильтров

24. JDBC Starter
Автоматически приходит как зависимост с spring data
Свойства - spring.jdbc (JdbcProperties)
JdbcTemplate - основной бин для запросов
NamedParameterJdbcTemplate расширяет JdbcTemplate и позволяет использовать именовынные параметры в запросах
Никак не связан с Hibernate, persistent context и сущностями. Хорошая практика из Resultset получать Dto или Projection

batch запросы - возможность выполнить несколько запросов (batchSize) за один сеанс tcp/ip связи с базой.
Обратно возвращается массив resultset-ов по числу запросов.
Выплоняется в одной трансакции, т.е. в случае не выполнения одного запроса, откатывается весь batch

Hibernate также отправляет batch запросы. По умолчанию bach_size = 50 (можно изменить в spring.jpa.properties.hibernate.bach_size )
batch запросы работают для insert, update, delete
Для select запросов существует параметр fetch_size, который задает коли-во записей, возвращаемых приложению. Если данных больше,
выполняется еще запрос (while(resultSet.next()) пока все данные не будут получены.

25. Spring MVC

Основан на шаблоне Front controller - единственный сервлет DispatcherServlet (конфигурация DispatcherServletAutoConfiguration)
Дефолтная конфигурация в WebMvcAutoConfiguration. Конфикорационные проперти - WebMvcProperties, WebProperties
Конфигурация встроенного web-сервера - ServletWebServerFactoryAutoConfiguration

Жизненный цикл DispatcherServlet:
- загрузка класса в web-сервер
- создание инстанса
- вызов метода init
- обработка входящих запросов в doGet/doPost/.../doXXX (реально в DispatcherServlet.doService)
- destroy при закрытии приложения

Задача DispatcherServlet.doService определить по урлу контроллер-обработчик запроса и вызвать его, передав ему входящие параметры
- mappedHandler = getHandler(processedRequest); - определение метода контроллера обработчика запроса (url path) и списка интерсепторов (вызываются перед и после метода)
- HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); - HandlerAdapter включает в себя WebApplicationContext и различные резолверы
   (RequestParamMethodArgumentResolver - обрабатывает @RequestParam, PathVariableMethodArgumentResolver - @PathVariable. см. DispatcherServlet.doDispatch() HandlerAdapter ha)
   Можно писать свои.
   Запускает метод контроллера и возвращает ModelAndView

Spring не имеет встроенной поддержики какого-нибудь варианта рендеринга View и по умолчанию возвращает результат "как есть"
Для подключения jsp нужна библиотека org.apache.tomcat.embed:tomcat-embed-jasper
В проперти
    spring.mvc.view:
          prefix: /WEB-INF/jsp - где лежат. важно указывать все "/"
          suffix: .jsp         - расширение файла.

Все контроллеры помечаются аннотацией @Controller
Все методы - @RequestMapping(value = "имя урла", method = RequestMethod.XXX), или сокращенный вариант - @GetMapping, @PostMapping и т.д.

Параметры запроса можно получить как параметр в методе, используя аннотация @RequestParam

Для установки сессионных атрибутов у контроллера объявляется аннотация @SessionAttributes с перечнем всех сессионных атрибутов.
При установке modelAndView.addObject(attributeName, attributeValue), attributeName сперва будет искаться в сессионных атрибутах,
а если не найден - будет устанавливаться как requestScope

Если специальный хендлер, обрабатывающиц ответ метода контроллера видит String в качестве возвращаемого результата, он интерпретирует
его как view.

Параметры формы или из get запроса мапятся на поля класса, помеченного @ModelAttribute
ModelAttribute может ставится и над методом, тогда этот метод будет вызываться перед каждым экщеном в контроллере.

Перенаправление запросов: forward, include, redirect
forward, include работают с сервлетами и jsp, redirect с url, поэтому более предпочтительный
Spring всегда делает forward или include (см InternalResourceView.renderMergedOutputModel())

Best practice for controllers
https://phauer.com/2015/restful-api-design-best-practices/

@PostMapping и @PutMapping используютя для соответственно create и update запросов, но поскольку в html-формах может быть
только put и get запросы, их можно применять только в REST-запросах

Трансакции по умолчания открываются на уровне контроллеров. Для отключения нужно установить параметр
        spring.jpa.open-in-view: false

Для добавления новых возможностей или изменения дефолтного поведения создается файл конфигурации, расширяющий WebMvcConfigurer
Пример формат даты
- в проперти файле параметр spring.mvc.format.date: yyyy-MM-dd (WebMvcProperties)
- аннотацию над полем @DateTimeFormat(pattern = "yyyy-MM-dd")
- создание форматтера в конфигурации.

26. Thymeleaf
https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax

27. Практика

RedirectAttributes attributes позволяет передать параметры с одного экшена другому
attributes.addAttribute - простые параметры (имя и тип должны соответствовать принимающей модели)
attributes.addFlashAttribute - объект (имя атрибута должно присутстовать в принимающей модели, или параметр помечен @ModelAttribute("имя атрибута"))

В spring mvc есть встроенная поддержка пейженации. В контексте уже лежит бин Pageable, который обрабатывает и устанавливает
PageableArgumentResolver

28. Database migration. Liquibase.
https://www.liquibase.com/
Существует две таблицы
databasechangeloglock - pessimistic lock. таблица, которую лочит накатываемый скрипт, тем самым исключает возможность обновления базы из нескольких
                        инстансов приложения
databasechangelog - insert into. следующим этапом скрипт, выполняющий обновление фиксирует скрипты обновления по id, author, filtname,  чтобы один и тот же
                    скрипт не выполнился несколько раз - они игнорируются. Если у файла изменился md5sum (чексумма файла) - т.е. он был уже изменен после накатывания
                    выбрасывается exception
changelog - собственно скрипт, который нужно накатить на БД. Бывает в форматах sql, xml, json, yaml
changeset - из них состоит changelog. обязательно указывается author:id. id уникален в пределах одного changelog и выполняется в транзакции.
change - составляющая часть changeset-а. 1 update = 1 change. желательно в одном changeset ставить один change

Интегрируетя со spring boot. LiquibaseAutoConfiguration
LiquibaseProperties (spring.liquibase)
    changeLog - путь к файлу, содержищему все changelog-и

29. Validation starter
Основа - jsr380(330) validation api и реализация в hibernate validation
https://hibernate.org/validator/documentation/
https://beanvalidation.org/2.0/
https://reflectoring.io/bean-validation-with-spring-boot/
https://www.baeldung.com/spring-mvc-custom-validator

Например, реализация @Email в org.hibernate.validator.internal.constraintvalidators.bv.EmailValidator
ValidatorImpl точка входа в валдацию
Все валидаторы являются компонентами

Для запуска процесса валидации над бином ставиться аннотация javax.validation.Valid или org.springframework.validation.annotation.Validated
(spring-аналог Valid, дополнительно позволяет указывать группы валидации)

Валидаторы можно разделить на группы. Если у валидатора нет явно указанной группы, он относится к группе javax.validation.groups.Default.class
Если Validated требуется валидация по группам, необходимо указывать все группы, включая Default

Ести валидатор проставлен над типом, то ошибки попадают в globalErrors, соответственно над полем - fieldErrors

Payload - интерфейс-маркер.
https://docs.jboss.org/hibernate/validator/5.0/reference/en-US/html/validator-customconstraints.html#validator-customconstraints-constraintannotation
С помощью наследников, указанный в валидаторе можно обрабатывать их в ConstraintViolation для, раализуя дополнительной логику валидации
ConstraintViolation возвращает ручной вызов validator.validate(...)

30. Rest (Representational State Transfer)

@PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE) - формат данных пришедшего запроса
@GetMapping(produces = MediaType.APPLICATION_JSON_VALUE) - формат ответа
@RequestBody - параметры в теле запроса

ControllerAdvice позволяет указать пакет контроллеров, для которых будет обрабатываться Exception
ResponseEntityExceptionHandler - абстрактый класс, содержащий меторы, обрабатывающие исключения в контроллерах
Написав свой класс-наследник с аннотацией ControllerAdvice, можно делать такую обработку.
В случае обычных контроллеров перенаправлять на страницу error, для rect контроллеров формировать json ответ с ошибками.
Например, обработчик ошибок валидации параметров - ResponseEntityExceptionHandler.handleMethodArgumentNotValid получает
MethodArgumentNotValidException, содержащий BindingResult

com.fasterxml.jackson.databind.ObjectMapper позволяет серилизовать объект в json и обратно.
https://javarush.com/quests/lectures/jru.module2.lecture31

Запросы к rest-контроллерам можно делать
- из idea Tools->HTTP client
- Postman
- swagger (зависимость springdoc-openapi-ui)

org.springdoc.core.Constants содержит свойства, в частности урл по которому генерится документация DEFAULT_API_DOCS_URL = "/v3/api-docs"
springdoc интегрирован с swagger:  DEFAULT_PATH_SEPARATOR + "swagger-ui.html" - которую генерит springdoc
http://localhost:8080/swagger-ui/index.html

тест
https://www.baeldung.com/sprint-boot-multipart-requests

31. Security starter

Аутентификация - пороверка подлинности пользователя (например, на основе логина и пароля)
Авторизация - проверка прав на выполнение определенных действий.

В случае HTTP servlets перез вызовом сервлета, вызывается цепочка объявленных фильров - javax.servlet.Filter, javax.servlet.FilterChain
Эти фильтры управляются контейнером сервлетов.
В Spring фильтры являются бинами и подчинены жизненному циклу бинов, поэтому управляются spring-ом.
Для этого существует один фильтр DelegatingFilterProxy, который принимает FilterChainProxy,
который в свою очередь управляет цепочкой вызовов фильтров - SecurityFilterChain
Цепочка фильтров (при каждом запросе вызывается последовательно)
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter
org.springframework.security.web.context.SecurityContextPersistenceFilter,
org.springframework.security.web.header.HeaderWriterFilter
org.springframework.security.web.csrf.CsrfFilter
org.springframework.security.web.authentication.logout.LogoutFilter
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter
org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter
org.springframework.security.web.authentication.www.BasicAuthenticationFilter
org.springframework.security.web.savedrequest.RequestCacheAwareFilter
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter
org.springframework.security.web.authentication.AnonymousAuthenticationFilter
org.springframework.security.web.session.SessionManagementFilter
org.springframework.security.web.access.ExceptionTranslationFilter
org.springframework.security.web.access.intercept.FilterSecurityInterceptor

SecurityFilterChain создается в SpringBootWebSecurityConfiguration и принимет HttpSecurity
HttpSecurity - билдер, который билдит SecurityFilterChain, а посути, основную конфигурацию Spring Security
HttpSecurity конфигурирует HttpSecurityConfiguration

Автоконфигурация SecurityAutoConfiguration, SecurityFilterAutoConfiguration
По умолчанию пользователь user, автогенеренный пароль выводится в консоль
Пользователь задается в пропертях spring.security.user name, passworl, role (org.springframework.boot.autoconfigure.security.SecurityProperties)

SecurityContext - обертка для объекта Authentication, в котором хранятся данные пользователь
SecurityContextHolder - занимается созданием/хранением SecurityContext
Имеет несколько стратегий хранения, основная - ThreadLocalSecurityContextHolderStrategy

SecurityContextPersistenceFilter через HttpSessionSecurityContextRepository устанавливает и берет текущего пользователя в javax.servlet.http.HttpSession
с именем аттрибута SPRING_SECURITY_CONTEXT
Затем вызывает SecurityContextHolder.setContext() и кладет в переменну TreadLocal<SecurityContext> SecurityContext пользователя.

Аунтетификация пользователя выполняется фильтром. Например, по логину и паролю - UsernamePasswordAuthenticationFilter.
В фильтре объявляет AuthenticationManager - класс, выполняющий аунтефикацию.
По умолчанию - ProviderManager, который содержит список провайдеров (наследники AuthenticationProvider), вызываемых последовательно.
Если какой-либо провайдер выполнил аунтефикацию - SecurityContext устанавливается.
По умолчанию - DaoAuthenticationProvider
DaoAuthenticationProvider.UserDetailsService = InMemoryUserDetailsManager по умолчанию в InitializeUserDetailsManagerConfigurer,
 если в контексте не переопределен UserDetailsService
Переопределенный сервис в методе loadUserByUsername должен выбрасывать UsernameNotFoundException, есть пользователь не найден
В сестеме должен быть только один переопределенный UserDetailsService.

Можно переопределить весь менеджер.
Тогда при инициализации ProviderManager-a в parent придет инстанс переопределенного менеджера
    ProviderManager(List<AuthenticationProvider> providers, AuthenticationManager parent)
Он будет вызван после отработки списка провайдеров в методе  authenticate(Authentication authentication)

Кастомная форма логина зависти о параметров, принимаемых UsernamePasswordAuthenticationFilter
        SPRING_SECURITY_FORM_USERNAME_KEY = "username";
	    SPRING_SECURITY_FORM_PASSWORD_KEY = "password";

31. Spring security. Basic authentification
    https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/index.html
примеры
    https://habr.com/ru/articles/545610/
    https://habr.com/ru/articles/278411/
    https://medium.com/code-with-farhan/spring-security-jwt-authentication-authorization-a2c6860be3cf
    https://www.toptal.com/spring/spring-security-tutorial
    https://www.toptal.com/web/cookie-free-authentication-with-json-web-tokens-an-example-in-laravel-and-angularjs

Аутентификация происходит с помощью параметра Authorization в header-e
При этом браузер автоматически открывает форму с логин/паролем
Получившийся токен имеет префикс Basic - параметр конвертера по умолчанию в BasicAuthenticationFilter BasicAuthenticationConverter
Конвертер парсит токен и возвращает UsernamePasswordAuthenticationToken
Далее обработка происходит в BasicAuthenticationFilter менеджером и провайдером по аналогии с UsernamePasswordAuthenticationFilter

32. Password encoder
Пароли храняться и проверяются в зашифрованном виде.
Для этого существуют специальные PasswordEncoder. Создаются в PasswordEncoderFactories
Пример работы в DaoAuthenticationProvider

33. Logout

LogoutConfigurer конфигурирует фильтр LogoutFilter, который обрабатывает дефолтный урл, если видит его в реквесте
При дефолтных настройках SecurityFilterChain существует еще фильтр DefaultLogoutPageGeneratingFilter (и пара ему DefaultLoginPageGeneratingFilter),
которые генерят дефолтные страницы логаута и логина.
Переопределение формы логина убирает дефолтную форму логаута.

34. Authorization filter
Проверка прав пользователя на ресурсы

FilterSecurityInterceptor - старая версия (устанавливается по умолчанию в SpringBootWebSecurityConfiguration http.authorizeRequests())
AuthorizationFilter - новая (включается командой http.authorizeRequest() )
Получает AuthorizationManager - функциональный интерфейс, который и выполняет проверку в методе check либо verify,
который выбрасывает AccessDeniedException("Access Denied").
Наследники
AuthenticatedAuthorizationManager - проверяет, что пользователь антентифицирован
AuthorityAuthorizationManager - проверяет роли
PreAuthorizeAuthorizationManager/PostAuthorizeAuthorizationManager - обрабатывают аннотации соответственно PreAuthorize и PostAuthorize
SecuredAuthorizationManager - обрабатываее аннотацию @Secured
RequestMatcherDelegatingAuthorizationManager - дефолтный обработчик. По RequestMatcher (урл) определяет менеджера и передает ему обработку

Права конфигурируются путем вызова соответствующий методов у HttpSecurity

PreAuthorize и PostAuthorize принимают SpEL, т.е. можно вызвать любой bean. SecurityExpressionRoot - класс методы которого можно вызывать в SpEL
PreAuthorize вызывается до вызова метода, PostAuthorize после и имеет доступ к результату returnObject
Чтобы заработали у конфигурационного файла нужно задать аннотацию @EnableMethodSecurity
Дополнительно эта аннотация разрешает использовать PreFilter, PostFilter, Secured, jsr250
Эти аннотации можно использовать не только в контроллерах, но и в сервисах, как над методом так и над типом

35. Security testing

Требуется зависимость org.springframework.security:spring-security-test
Аннотация @WithMockUser(username, password, authorities) устанавливает пользователья в контекст. Значения неважны.
Можно установить над типом, над методом, если требуется отличный от общего пользователь, либо вызвать get()/post() c
вызовом методы with()

36 OAuth 2.0
https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/oauth2login-advanced.html

Если есть несколько приложение с аунтентификацией неудобно в каждом хранить базу с паролями пользователей и, соответсвенно,
держать логин-форму с требованием зарегистироваться
OAuth - единый внешний механизм аунтентификации

Будут подключины два фильтра
OAuth2AuthorizationRequestRedirectFilter
OAuth2LoginAuthenticationFilter

CommonOAuth2Provider - предустановленные провайдеры

37 JSON Web Token (JWT)

Токен получен в OidcUserRequest от сайта, отвечающего за аунтентификацию.
https://jwt.io/ - расшифровка токена (кодируется в base64)

38. Outh2 в swagger

Настраивается через пороперти. Названия аналогичны как для приложения
Плюс конфигурация с указанием сервера аунтентификации

39. Интернационализация

установить в Idea
Settings -> File encoding:
 - Default enconding for properties files: UTF-8
 - Установить чекбокс Transparent native......

 При использовании  MessageSource
 - в пропертях прописываем свойство
        spring.messages.basename: messages
 - создаем дефолтный файл messages.properties

 LocaleChangeInterceptor и LocaleResolver определяют параметр request текущей локали и способ ее хранения.

 40. Aspect
https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html

Конфигурация AopAutoConfiguration
Аоп подключается автоматически.
    @ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)
Если в пропертях явно не задано свойство spring.aop.auto=false
Ранее нужно было указывать аннотацию EnableAspectJAutoProxy
Также по умолчанию используется CJLib proxy

Аспектно-ориентированное программирование (АОП) — это парадигма программирования, заключается в выделении так называемой сквозной функциональности
в программный код, физически отельный от основного программного кода.

 Spring AOP работает в runtime (в отличии от AspectJ, которое работает на этапе компиляции), поэтому может быть реализовано только для методов.
Все аспекты должны быть бинами (т.е. помечены как Component)

Pointcut — это срез, запрос точек присоединения.
Создание Pointcut - реализация интерфейса org.springframework.aop.Pointcut
 - ClassFilter getClassFilter() - ClassFilter через метод boolean matches(Class<?> clazz) определяет следует ли применять скозную функциональность
    для переданного класса
 - MethodMatcher getMethodMatcher() - следующий уровень, определяющие возможность применения сквозной функциональности к методама выбранного класса.

Для того чтобы не создавать объект-реализацию этого интерфейса, существует аннотация  org.aspectj.lang.annotation.Pointcut,
которая ставится над пустым методом и в которой описываются правила выбора классов и методов.
Правила запросов точек очень разнообразные, имеют определенный синтаксис и их можно объединять по &&, ||,!
Правило по сути является предикатом и похоже на регулярное выражение, возвращающее true|false.
Описывается с помощью ключевых слов (описаны в AspectJExpressionPointcut/PointcutPrimitive): within, @within, this, args, @args, @annotation, target, @target, bean, execution
Выражение начинающиеся с @ относятся к аннотации
https://www.baeldung.com/spring-aop-pointcut-tutorial
https://docs.spring.io/spring-framework/reference/core/aop/ataspectj/pointcuts.html

Advice - реализация логики аспекта для указанного Pointcut
Бывают - Before, After, AfterReturning, AfterThrowing, Round

Недостаток АОП - возможность сломать аспект в результате рефакторинга и, следовательно,  трудно обнаруживаемые ошибки
Например использование args - т.е. привязка к аргументам метода. Изменение набара аргументов поломает аспект.

В stacktarace искать вызов CglibAopProxy.proceed
в this можно увидеть какой прокси объект аспектом создан, targer объект, вызываемый из аспекта метод и его аргументы
interceptorsAndDynamicMethodMatchers - список интерцепторов. Каждый advice создает интерсептор.
для метода UserService.findById, помимо addLogging() advice-интерсептора (MethodBeforeAdviceInterceptor), будет
 - TransactionInterceptor, т.к. сервис помечен аннотацией Trancactonal (аналог advice aspect)
 - AuthorizationManagerBeforeMethodInterceptor, т.к. метод помечен аннотацией PreAuthorize
