1.
Inversion of Control - принцип программирования, при котором управлением выполнения программы (созданием объектов в частности) занимается фреймворк, а не программист
Происходит потеря контроля над управлением кодом: фреймворк управляет кодом программиста. Однако программист сосредотачивается над написанием бизнесслогики.

IoC Spring - Dependency Injection (DI)
DI внедряет зависимости через конструктор класса, параметры статического метода инициализации (фабричный метод), свойства объекта (set-методы)

IoC Container - объект, который занимается созданием других объектов (Bean типа Controller, Service, Repository) и внедрением в них зависимостей (DI).
Представляет собой ассоциативный массив (Map). 

IoC Container-у требуется метаинформация (Bean Definitions), которая описывае как создавать Beans, конфигурировать и внедрять в них зависимости.
Работает на основе Reflection API 
Существует три реализации метаинформации: XML-based, Annotation-based, Java-based

IoC Container pеализует интерфейсы org.springframework.beans.factory.BeanFactory и org.springframework.context.ApplicationContext
Для хмл-конфигурации - ClassPathXmlApplicationContext.
Содержит параметр beanFactory - метаинформация (Bean definition) о всех бирнах в конфигурации (пользовательскии и конфигурационные)
* beanDefinitionMap - мап бинов, где ключ - полное имя класс либо парамет id/name из конфигурации
        <bean id="..." name="" ...>
    Каждый параметр value содержит его метаинформацию
    constructorArgumentValues - метаинформация о аргументах конструктора (indexArgumentValues, если в конфигурации испольнован индех аргумента в конструкторе
    или genericArgumentValues, если по имени или типу параметра)

* beanDefinitionNames - список имен бинов
* singletonObjects - map эекземпляров классов бинов с ключем по имени. Собственно объект, возвращаемый по требованию
* beanPostProcessors

2.
Жизненный цикл бинов

Bean definition. Метаинформация о зависимотях и параметрах бинов. Собирается на основе конфигурционных файлов, аннотаций, java-конфигов.

Bean factory post processors
Бины, реализующие интерфейс BeanFactoryPostProcessor
Дополнительная обработка метаинформации. Как пример - внедрение информации из properties файлов.

Сортировка бинов из Bean definition.
Т.к. бины могут зависеть друг от друга, происходит их сортировка и инициализируются первыми независимые от других бины.

Вызов конструкторов бинов либо фабричного метода
    <bean name="..." class="..." factory-method="of">

Вызов set-методов
В хмл-конфигурации свойство
    <property name="properties"> <!-- setProperties(args)  -->

Bean post processors. Before initialization.
Бины, реализующие интерфейс BeanPostProcessor. Вызываются перед инициализацией бинов

Initialization callbacks
Инициализация бинов. Осуществляется тремя способами (в порядке приоритета)
1) аннотация @PostConstruct над методом
2) метод afterPropertiesSet. Класс должен реализовывать интерфейс InitializingBean
3) init-метод, прописанный в конфигурации
    <bean class="..."   init-method="init">

Bean post processors. After initialization.

Beans
Создание и возвращение бина вызывающему процессу.
В случае singleton-бина - бин кладется в контекст и существует в единственном экземпляре.

Destruction callbacks
Для singleton-бинов при закрытии контекста вызывается прописанный в конфигурации метод
    <bean class="...." scope="singleton"  destroy-method="destroyMethod">

3.
Bean factory post processors
 Являются обычными бинами, проходящими тот же жизненный цикл, только в первую очередь.
 Для этого Spring в списка бинов из конфигурации отбирает их и сортирует в порядке объявления, либо наличии
 реализуемых интерфейсов Ordered и PriorityOrdered (имеет высший приоритет) и возвращаемого значения из
 getOrder() (чем меньше число, тем больший приоритет).
 Определение принадлежности к классу beans post processors
       BeanFactoryPostProcessor.class.isAssignableFrom(bfpp.getClass())

4.
Bean post processors (annotationsConfig.png)
Позволяют управлять конфигурацией бинов посредством обработки аннотаци, что расширяет функционал
CommonAnnotationBeanPostProcessor - обрабатывает аннотации @PreDestroy, @PostConstruct (initialize callbacks), @Resource
ApplicationContextAwareProcessor - важный конфигурационный bpp, обрабатывающий бины, реализающие интерфейс Aware (осведомители)
Эти интерфейсы позволяют внедрить в бин различные конфигурационные объекты, включая контекст.
CommonAnnotationBeanPostProcessor реализует BeanFactoryAware, позволяющий получить BeanFactory
    public void setBeanFactory(BeanFactory beanFactory) {...}

С помощью bpp можно создавать обертки (proxy) бинов (AuditingBeanPostProcessors, TransactionBeanPostProcessors).

5. @Autowired, @Resource, @Value
Обрабатываются соответствующими bpp (annotationsConfig.png)
@Autowired - spring аннотация для внедрения зависимостей. Более функциональная чем @Resource
позволяет внедрять массивы, коллекции, мапы
Если в конфигурации есть несколько бинов одинакового типа, используется аннотация @Qualifier("...") с указанием id конкретного бина
Либо можно указать имя поля такое же как id.
Может устанавливатся над методами, но тогда имя параметра должно соответствовать id бина
Поскольку xml-конфигурация для создания бина требует конструктор, а если есть парамеры, то их нужно инициализировать -
@Autowired над конструктором нет смысла ставить.
@Autowired над конструктором ставится в конфигурации через аннотации и java
@Autowired над конструктором ставится если есть несколько конструкторов

@Resource - java аннотация в соответсвии с jsr250

@Value - позволяет внедрять заначения из property-файлов с использованием EL или SpEL

6. Classpath scanning
        <context:component-scan base-package="..."/>
base-package - перечень пакетов для сканировани. Бины для bean definitions должны быть помечены как
        @Component, @Repository, @Service, @Controller, @RestController
чисто логическое деление. Все являются @Component

в случае xml обработкой занимается ComponentScanBeanDefinitionParser, аннотаций - ComponentScanAnnotationParser, а
так же сооветствующие readers (componentScans.png, beanDefinitionReaders.png)

component-scan использует фильры для поиска бинов (componentScanFilters.png)
annotation - дефолтное поведение при use-default-filters="true". Ищутся все бины с аннотацией @Component (с потомками)

scope-resolver - класс определяющий scope бинов - singleton/prototype. По умолчанию в spring-context.xsd - ScopeMetadataResolver и его реализация AnnotationScopeMetadataResolver
AnnotationScopeMetadataResolver ищет аннотацию Scope.
помимо парамета value (singleton/prototype) имеет парамер proxyMode, позволяющий создавать прокси из бина

7. Java configuration
Обрабатывается ConfigurationClassPostProcessor-ром, который ищет классы, помеченные аннотацией @Configuration

Классы конфигурации по умолчанию создаются как прокси (proxyBeanMethods() default true;), поэтому бины, которые создаются
в методах через new на самом деле создаются только один раз.

@Bean
параметры initMethod(), destroyMethod() - аналоги @PostConstruct, @PreDestroy

@Profile("...")  - помеченная этой аннотацией сущность, будет создаваться в указанном профайле
Профайлов может быть несколько. К ним применимы операции ! & |
Активация профиля проводится чаще всего в файле Properties
    spring.profiles.active=web,prod
второй вариант через контекст
    context.getEnvironment().setActiveProfiles("web", "prod")

8. Listeners
Предствляет собой реализацию шаблона Слушатель событий
Обрабатываются bpp EventListenerMethodProcessor
Оперирует объектами Event (наследник ApplicationEvent или базового EventObject) - обычный POJO и Listener c произвольным методом acceptXXXX(Event),
помеченным аннотацией @EventListener
Неявно на основании каждой аннотации @EventListener будет создан объект типа ApplicationListener
Отслеживание событий (публикация евентов) осуществляется объектом-наследником интерфейса ApplicationEventPublisher
вызовом метода publishEvent. В результате из контекста будут вызываться все методы, помеченные аннотацией @EventListener и принимающие
соответствеющий параметр Event.
@EventListener имеет параметр condition, в котором на SpEL можно писать условие выполнения метода слушателя.

9. Spring boot
Spring -  альтернатива Java EE и EJB-бинам, фреймворк, реализующий по-своему Java EE стандарт.
Состоит из набора независимых модулей -
core — базовый функционал, реализующий понятия IoC (inversion of control) и DI (dependency injection);
AOP — Aspect-Oriented Programming — аспектно-ориентированое программирование, направленное на реализацию сквозной логики;
MVC и WebFlux — фреймворки для веб взаимодествия;
JDBC, ORM — технологии взаимодействия с базами данных;
Test — функционал для прозрачного, несложного тестирования данных Spring контейнера;
SpEL — Spring Expression Language — язык выражений Spring;
и т.д.
Каждый модуль - набор отдельных библиотек и своей конфигурации в приложении

Spring boot через Spring boot starters предоставляет возможность автоконфигурации каждого модуля и
решает проблему совместимости библиотек.
Версия Spring boot-а предоставляет pom, в котором указаны все зависимости библиотек, которые были протестированы
на совместимость в данной версии (Dependency management механизм)

@Conditional - позволяет динамически подключать конфигурацию, модуль, бин на основе написанного условия.
@Profile - пример реализации

Класс, запускающий приложение, должен быть помечен аннотацией @SpringBootApplication и быть единственным.
Эта аннотация помечается аннотациями
 - @SpringBootConfiguration, также единственная
 - @ComponentScan - автоматически сканирует все пакеты, которые входят в пакет с главным классом приложения

 application.properties - зарезервированное имя файла свойств, поэтому в конфигурации нет необходимости явно
 вызывать @PropertySource("classpath:application.properties")

spring.properties - еще один файл свойств, который читает специальным классом SpringProperties

Существует 14 вариантов передачи свойсв в приложение
https://docs.spring.io/spring-boot/reference/features/external-config.html
в зависимости от источника свойства могут переопределятся
application-{profile}.properties - свойства, связанные с профайлом

VM: -Ddb.username=wpsadmin2
command args: --db.username=wpsadmin2
Envirement: db.username=wpsadmin2

10. Yaml - yet another markup language
хорошо работает со сложными структурами (List, Map), позволяет создавать Java объекты
Обрабатывается YamlPropertiesFactoryBean
Не рекомендуется одновременное использование application.properties и application.yaml (*.yml)
Названия полей в Java объекте должны быть такими же как в файле.
Объект должен иметь конструктор без параметров и get/set методы, т.к. заполнение значениями происходит через Reflection
Маппинг файла на объект
- создание бина с аннотацией @ConfigurationProperties
- @ConfigurationProperties у бина + @ConfigurationPropertiesScan у класса приложения

11. Logging
По умоляанию - Logback
Дефолтные настройки логирования лежат в base.xml
В пропертях можно донастраивать или переопределять параметры - параметр logging

12. Testing
Для unit тестов необходим только MockitoExtension
Для интегрейшен тестов необходим контекст приложения для инициализации бинов и внедрения зависимостей
Для этого необходимо указать главный класс приложения (@SpringBootApplication), в котором происходит конфигурирования

Тесты не работают с yaml файлами. По умолчанюи только с *.properties
Поэтому, если какой-то @Component для инициализации требует проперти - в тестах не подымится ApplicationContext
Будет ошибка создания бина
    Error creating bean with name 'connectionPool' defined in file ....\ConnectionPool.class]:
    Unexpected exception during bean creation; nested exception is java.lang.IllegalArgumentException:
    Could not resolve placeholder 'db.username' in value "${db.username}"

для решения проблемы нужно использовать ConfigDataApplicationContextInitializer, который вызывает ConfigDataEnvironmentPostProcessor,
который в свою очередь обрабатывает все property в classpath

Все вышесказанное делает автоматически аннотация @SpringBootTest

@ActiveProfiles("test") - активирует тестовый профайл, соответственно будет считываться  application-test.yml,
свойства в котором будут перезаписывать application.yml

Вместо @Autowired для полей нужен конструктор. Для этого используется аннотация
    @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)

либо прописываем в spring.properties свойство (https://docs.spring.io/spring-framework/reference/appendix.html)
    spring.test.constructor.autowire.modе=all